#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>

#include "lib.h"
#include "conf.h"
#include "discord_game_sdk.h"


/* 1. ERR
 * 2. SONG
 * 3. ADVERTISEMENT
 */
int classify(struct Video video) {

    // if there is an album, it is a song
    if (strlen(video.album) > 0) {
        return 2;
    }

    FILE *output;
    char type[15];

    char command[130];
    sprintf(command, "python3 ./src/ml/classify.py \"%s\" \"%s\"", video.title, video.artist);

    output = popen(command, "r");
    if (output == NULL) {
        pclose(output);

        printf("Failed to run command\n");
        return 1;
    }

    fgets(type, 14, output);

    pclose(output);

    if (strcmp(type, "song\n") == 0) {
        return 2;
    } else if (strcmp(type, "advertisement") == 0) {
        return 3;
    } else {
        return 1;
    }
}

struct Video get_current_video() {
    FILE *output;
    struct Video video = { "", "", "", 0 };
    int state = 0;

    output = popen("nowplaying-cli get title artist album playbackRate", "r");

    if (output == NULL) {
        pclose(output);
        return video;
    }

    fgets(video.title, 50, output);
    fgets(video.artist, 50, output);
    fgets(video.album, 50, output);
    fscanf(output, "%d", &state);

    pclose(output);

    if (state > 0) {
        video.state = 1;
    }
    
    // Remove newline characters
    video.title[strcspn(video.title, "\n")] = 0;
    video.artist[strcspn(video.artist, "\n")] = 0;

    return video;
}

void update_presence(struct IDiscordActivityManager* activity_manager, struct Video video)  {
   struct DiscordActivity activity;
    memset(&activity, 0, sizeof(activity));
    strcpy(activity.state, video.artist);
    strcpy(activity.details, video.title);
    strcpy(activity.assets.large_image, "ytm"); // Image key from your Discord application
    strcpy(activity.assets.large_text, "youtube music");
    strcpy(activity.assets.small_image, "mystique"); // Image key from your Discord application
    strcpy(activity.assets.small_text, "provided by mystique");
    activity.type = 2;

    activity_manager->update_activity(activity_manager, &activity, NULL, NULL);
}

int start_daemon() {

    char *daemon_path = getenv("DAEMON_TXT");
    if (daemon_path == NULL) {
        printf("DAEMON_TXT environment variable is not set, defaulting to daemon.txt\n");
        daemon_path = "daemon.txt";
    }

    // save procid to file
    // line 1: THIS FILE IS GENERATED BY MYSTIQUE, IT CONTAINS INFORMATION ABOUT THE CURRENTLY RUNNING DAEMON. DO NOT EDIT ANY VALUES UNLESS YOU KNOW WHAT YOU ARE DOING!
    // line 2: <version>
    // line 3: <pid>
    // line 4: <state> 
    // 1 = running
    // 0 = stopped
    FILE *file = fopen(daemon_path, "r");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    // skips first 3 lines
    char buffer[100];
    fgets(buffer, 100, file);
    fgets(buffer, 100, file);
    fgets(buffer, 100, file);
    fgets(buffer, 100, file);


    int state;
    fscanf(file, "%d", &state);
    if (state == 1) {
        printf("Daemon is already running\n");
        return 0;
    }


    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid > 0) {
        return 0;
    }

    file = fopen(daemon_path, "w");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    fprintf(file, "THIS FILE IS GENERATED BY MYSTIQUE, IT CONTAINS INFORMATION ABOUT THE CURRENTLY RUNNING DAEMON. DO NOT EDIT ANY VALUES UNLESS YOU KNOW WHAT YOU ARE DOING!\n");
    fprintf(file, "%s\n", VERSION);
    fprintf(file, "%d\n", getpid());
    fprintf(file, "1\n");

    fclose(file);

    struct IDiscordCore* core;
    struct DiscordCreateParams params;
    DiscordCreateParamsSetDefault(&params);
    params.client_id = 1270609373244428298;
    params.flags = DiscordCreateFlags_NoRequireDiscord;

    enum EDiscordResult result = DiscordCreate(DISCORD_VERSION, &params, &core);
    if (result != DiscordResult_Ok) {
        printf("Failed to initialize Discord SDK: %d\n", result);
        return -1;
    }

    struct IDiscordActivityManager* activity_manager = core->get_activity_manager(core);

    struct Video video = { "this", "is", "a test", 0 };
    struct Video last_video = { "", "", "" };

    // stfu it works
    while (1) {
        video = get_current_video();
        core->run_callbacks(core);
        // if the video is not playing, skip
        if (video.state == 0) {
            activity_manager->clear_activity(activity_manager, NULL, NULL);
            sleep(4);
            continue;
        }

        update_presence(activity_manager, video);

        // if the video is an advertisement, skip 1000 seconds
        int type = classify(video);
        if (type == 3) {
            system("nowplaying-cli seek 1000");
        }

        last_video = video;
        sleep(4);
    }

    core->destroy(core);
}

int stop_daemon() {
    
    char *daemon_path = getenv("DAEMON_TXT");
    if (daemon_path == NULL) {
        printf("DAEMON_TXT environment variable is not set, defaulting to daemon.txt\n");
        daemon_path = "daemon.txt";
    }

    FILE *file = fopen(daemon_path, "r");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    char version[10];
    int pid;
    int state;

    // skips first line
    char c;
    while ((c = fgetc(file)) != '\n');

    fgets(version, 10, file);
    fscanf(file, "%d", &pid);
    fscanf(file, "%d", &state);

    fclose(file);

    if (state == 0) {
        printf("Daemon is already stopped\n");
        return 0;
    }

    kill(pid, SIGKILL);

    file = fopen(daemon_path, "w");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    fprintf(file, "THIS FILE IS GENERATED BY MYSTIQUE, IT CONTAINS INFORMATION ABOUT THE CURRENTLY RUNNING DAEMON. DO NOT EDIT ANY VALUES UNLESS YOU KNOW WHAT YOU ARE DOING!\n");
    fprintf(file, "%s", version);
    fprintf(file, "%d\n", pid);
    fprintf(file, "0");

    fclose(file);

    return 0;
}

int repair_daemon() {
    // Step 1: verrify daemon.txt

    char *daemon_path = getenv("DAEMON_TXT");
    if (daemon_path == NULL) {
        printf("DAEMON_TXT environment variable is not set! Consider resinstalling (unless this is in a devleopment environment)\n");
        daemon_path = "daemon.txt";
    }

    FILE *file = fopen(daemon_path, "r");
    if (file == NULL) {
        perror("No Daemon file found, creating one\n");
        

        return 1;
    }

    printf("Repairing daemon.txt\n");

    file = fopen(daemon_path, "w");
    if (file == NULL) {
        perror("fopen");
        return 1;
    }

    fprintf(file, "THIS FILE IS GENERATED BY MYSTIQUE, IT CONTAINS INFORMATION ABOUT THE CURRENTLY RUNNING DAEMON. DO NOT EDIT ANY VALUES UNLESS YOU KNOW WHAT YOU ARE DOING!\n0.1.0\n55300\n0");

    fclose(file);

    return 0;

}
